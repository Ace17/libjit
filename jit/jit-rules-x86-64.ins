/*
 * jit-rules-x86-64.ins - Instruction selector for x86_64.
 *
 * Copyright (C) 2008  Southern Storm Software, Pty Ltd.
 *
 * This file is part of the libjit library.
 *
 * The libjit library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * The libjit library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with the libjit library.  If not, see
 * <http://www.gnu.org/licenses/>.
 */
 
%regclass reg x86_64_reg
%regclass creg x86_64_creg
%regclass rreg x86_64_rreg
%regclass sreg x86_64_sreg
%regclass freg x86_64_freg
%regclass xreg x86_64_xreg
 
/*
 * Conversion opcodes.
 */

JIT_OP_TRUNC_SBYTE:
	[=reg, reg] -> {
		x86_64_movsx8_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_TRUNC_UBYTE:
	[=reg, reg] -> {
		x86_64_movzx8_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_TRUNC_SHORT:
	[=reg, reg] -> {
		x86_64_movsx16_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_TRUNC_USHORT:
	[=reg, reg] -> {
		x86_64_movzx16_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_TRUNC_INT:
	[=reg, reg] -> {
		if($1 != $2)
		{
			x86_64_mov_reg_reg_size(inst, $1, $2, 4);
		}
	}

JIT_OP_TRUNC_UINT:
	[=reg, reg] -> {
		if($1 != $2)
		{
			x86_64_mov_reg_reg_size(inst, $1, $2, 4);
		}
	}

JIT_OP_LOW_WORD:
	[=reg, imm] -> {
		x86_64_mov_reg_imm_size(inst, $1, $2, 4);
	}
	[=reg, local] -> {
		x86_64_mov_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[=reg, reg] -> {
		if($1 != $2)
		{
			x86_64_mov_reg_reg_size(inst, $1, $2, 4);
		}
	}
	
JIT_OP_EXPAND_INT:
	[=reg, reg] -> {
		x86_64_movsx32_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_EXPAND_UINT:
	[=reg, reg] -> {
		x86_64_mov_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_NFLOAT_TO_INT: stack
	[=reg, freg] -> {
		/* allocate space on the stack for 2 shorts and 1 int */
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
		/* store FPU control word */
		x86_64_fnstcw_membase(inst, X86_64_RSP, 0);
		/* set "round toward zero" mode */
		x86_64_mov_reg_membase_size(inst, $1, X86_64_RSP, 0, 2);
		x86_64_or_reg_imm_size(inst, $1, 0xc00, 2);
		x86_64_mov_membase_reg_size(inst, X86_64_RSP, 2, $1, 2);
		x86_64_fldcw_membase(inst, X86_64_RSP, 2);
		/* convert float to int */
		x86_64_fistp_membase_size(inst, X86_64_RSP, 4, 4);
		/* restore FPU control word */
		x86_64_fldcw_membase(inst, X86_64_RSP, 0);
		/* move result to the destination */
		x86_64_mov_reg_membase_size(inst, $1, X86_64_RSP, 4, 4);
		/* restore the stack */
		x86_64_add_reg_imm_size(inst, X86_64_RSP, 8, 8);
	}

JIT_OP_NFLOAT_TO_LONG: stack
	[=reg, freg] -> {
		/* allocate space on the stack for 2 shorts and 1 long */
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 12, 8);
		/* store FPU control word */
		x86_64_fnstcw_membase(inst, X86_64_RSP, 0);
		/* set "round toward zero" mode */
		x86_64_mov_reg_membase_size(inst, $1, X86_64_RSP, 0, 2);
		x86_64_or_reg_imm_size(inst, $1, 0xc00, 2);
		x86_64_mov_membase_reg_size(inst, X86_64_RSP, 2, $1, 2);
		x86_64_fldcw_membase(inst, X86_64_RSP, 2);
		/* convert float to long */
		x86_64_fistp_membase_size(inst, X86_64_RSP, 4, 8);
		/* restore FPU control word */
		x86_64_fldcw_membase(inst, X86_64_RSP, 0);
		/* move result to the destination */
		x86_64_mov_reg_membase_size(inst, $1, X86_64_RSP, 4, 8);
		/* restore the stack */
		x86_64_add_reg_imm_size(inst, X86_64_RSP, 12, 8);
	}

JIT_OP_NFLOAT_TO_FLOAT32: stack
	[=xreg, freg] -> {
		/* Avoid modifying the stack pointer by simply using negative */
		/* offsets here. */
		x86_64_fstp_membase_size(inst, X86_64_RSP, -8, 4);
		x86_64_movss_reg_membase(inst, $1, X86_64_RSP, -8);
	}

JIT_OP_NFLOAT_TO_FLOAT64: stack
	[=xreg, freg] -> {
		/* Avoid modifying the stack pointer by simply using negative */
		/* offsets here. */
		x86_64_fstp_membase_size(inst, X86_64_RSP, -8, 8);
		x86_64_movsd_reg_membase(inst, $1, X86_64_RSP, -8);
	}

/*
 * Data manipulation.
 */

JIT_OP_COPY_LOAD_SBYTE, JIT_OP_COPY_LOAD_UBYTE, JIT_OP_COPY_STORE_BYTE: copy
	[=local, imm] -> {
		x86_64_mov_membase_imm_size(inst, X86_64_RBP, $1, $2, 1);
	}
	[=local, reg] -> {
		x86_64_mov_membase_reg_size(inst, X86_64_RBP, $1, $2, 1);
	}
	[reg] -> {}

JIT_OP_COPY_LOAD_SHORT, JIT_OP_COPY_LOAD_USHORT, JIT_OP_COPY_STORE_SHORT: copy
	[=local, imm] -> {
		x86_64_mov_membase_imm_size(inst, X86_64_RBP, $1, $2, 2);
	}
	[=local, reg] -> {
		x86_64_mov_membase_reg_size(inst, X86_64_RBP, $1, $2, 2);
	}
	[reg] -> {}

JIT_OP_COPY_INT: copy
	[=local, imm] -> {
		x86_64_mov_membase_imm_size(inst, X86_64_RBP, $1, $2, 4);
	}
	[reg] -> {}

JIT_OP_COPY_LONG: copy
	[=local, imm, if("$2 >= jit_min_int && $2 <= jit_max_int")] -> {
		x86_64_mov_membase_imm_size(inst, X86_64_RBP, $1, $2, 8);
	}
	[reg] -> {}

JIT_OP_COPY_FLOAT32: copy
	[=local, xreg] -> {
		x86_64_movss_membase_reg(inst, X86_64_RBP, $1, $2);
	}
	[xreg] -> {}

JIT_OP_COPY_FLOAT64: copy
	[=local, xreg] -> {
		x86_64_movsd_membase_reg(inst, X86_64_RBP, $1, $2);
	}
	[xreg] -> {}

JIT_OP_COPY_NFLOAT: copy, stack
	[freg] -> {}

JIT_OP_COPY_STRUCT:
	[=frame, frame, scratch reg, scratch xreg,
		if("jit_type_get_size(jit_value_get_type(insn->dest)) <= _JIT_MAX_MEMCPY_INLINE")] -> {
		inst = small_struct_copy(gen, inst, X86_64_RBP, $1, X86_64_RBP, $2,
								 jit_value_get_type(insn->dest), $3, $4);
	}
	[=frame, frame, clobber(creg), clobber(xreg)] -> {
		inst = memory_copy(gen, inst, X86_64_RBP, $1, X86_64_RBP, $2,
				   jit_type_get_size(jit_value_get_type(insn->dest)));
	}

JIT_OP_ADDRESS_OF:
	[=reg, frame] -> {
		x86_64_lea_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}

/*
 * Stack pushes and pops.
 */

JIT_OP_PUSH_INT: note
	[imm] -> {
		x86_64_push_imm(inst, $1);
		gen->stack_changed = 1;
	}
	[local] -> {
		x86_64_push_membase_size(inst, X86_64_RBP, $1, 4);
		gen->stack_changed = 1;
	}
	[reg] -> {
		x86_64_push_reg_size(inst, $1, 4);
		gen->stack_changed = 1;
	}

JIT_OP_PUSH_LONG: note
	[imm] -> {
		if(($1 >= (jit_nint)jit_min_int) && ($1 <= (jit_nint)jit_max_int))
		{
			x86_64_push_imm(inst, $1);
		}
		else
		{
			jit_int *ptr = (jit_int *)&($1);
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
			x86_64_mov_membase_imm_size(inst, X86_64_RSP, 4, ptr[1], 4);
			x86_64_mov_membase_imm_size(inst, X86_64_RSP, 0, ptr[0], 4);
		}
		gen->stack_changed = 1;
	}
	[local] -> {
		x86_64_push_membase_size(inst, X86_64_RBP, $1, 8);
		gen->stack_changed = 1;
	}
	[reg] -> {
		x86_64_push_reg_size(inst, $1, 8);
		gen->stack_changed = 1;
	}

JIT_OP_PUSH_FLOAT32: note
	[imm] -> {
		jit_int *ptr = (jit_int *)($1);
		x86_64_push_imm_size(inst, ptr[0], 4);
		gen->stack_changed = 1;
	}
	[local] -> {
		x86_64_push_membase_size(inst, X86_64_RBP, $1, 4);
		gen->stack_changed = 1;
	}
	[xreg] -> {
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
		x86_64_movss_membase_reg(inst, X86_64_RSP, 0, $1);
		gen->stack_changed = 1;
	}

JIT_OP_PUSH_FLOAT64: note
	[imm] -> {
		jit_int *ptr = (jit_int *)($1);
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
		x86_64_mov_membase_imm_size(inst, X86_64_RSP, 4, ptr[1], 4);
		x86_64_mov_membase_imm_size(inst, X86_64_RSP, 0, ptr[0], 4);
		gen->stack_changed = 1;
	}
	[local] -> {
		x86_64_push_membase_size(inst, X86_64_RBP, $1, 8);
		gen->stack_changed = 1;
	}
	[xreg] -> {
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
		x86_64_movsd_membase_reg(inst, X86_64_RSP, 0, $1);
		gen->stack_changed = 1;
	}

JIT_OP_PUSH_NFLOAT: note, stack
	[imm] -> {
		jit_int *ptr = (jit_int *)($1);
		if(sizeof(jit_nfloat) != sizeof(jit_float64))
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, 16, 8);
			x86_64_mov_membase_imm_size(inst, X86_64_RSP, 8, ptr[2], 4);
		}
		else
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, sizeof(jit_float64), 8);
		}
		x86_64_mov_membase_imm_size(inst, X86_64_RSP, 4, ptr[1], 4);
		x86_64_mov_membase_imm_size(inst, X86_64_RSP, 0, ptr[0], 4);
		gen->stack_changed = 1;
	}
	[local, scratch reg] -> {
		if(sizeof(jit_nfloat) != sizeof(jit_float64))
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, 16, 8);
			x86_64_mov_reg_membase_size(inst, $2, X86_64_RBP, $1 + 8, 4);
			x86_64_mov_membase_reg_size(inst, X86_64_RSP, 8, $2, 4);
		}
		else
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
		}
		x86_64_mov_reg_membase_size(inst, $2, X86_64_RBP, $1, 8);
		x86_64_mov_membase_reg_size(inst, X86_64_RSP, 0, $2, 8);
		gen->stack_changed = 1;
	}
	[freg] -> {
		if(sizeof(jit_nfloat) != sizeof(jit_float64))
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, 16, 8);
			x86_64_fstp_membase_size(inst, X86_64_RSP, 0, 10);
		}
		else
		{
			x86_64_sub_reg_imm_size(inst, X86_64_RSP, sizeof(jit_float64), 8);
			x86_64_fstp_membase_size(inst, X86_64_RSP, 0, 8);
		}
		gen->stack_changed = 1;
	}

JIT_OP_PUSH_STRUCT: note, more_space
	[reg, if("((jit_nuint)jit_value_get_nint_constant(insn->value2)) <= 32")] -> {
		jit_nuint size;
		jit_nuint last_part;
		size = (jit_nuint)jit_value_get_nint_constant(insn->value2);
		last_part = size & 0x7;
		if(last_part)
		{
			/* Handle the possible last part smaller than 8 bytes */
			size -= last_part;

			/* We don't care about the last not needed bytes */
			x86_64_push_membase_size(inst, $1, size, 8);
		}
		/* Handle full multiple pointer sized parts */
		while(size > 0)
		{
			size -= sizeof(void *);
			x86_64_push_membase_size(inst, $1, size, 8);
		}
		gen->stack_changed = 1;
	}
	[reg, clobber(creg), clobber(xreg)] -> {
		/* Handle arbitrary-sized structures */
		jit_nuint size;
		size = (jit_nuint)jit_value_get_nint_constant(insn->value2);
		/* TODO: Maybe we should check for sizes > 2GB? */
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, ROUND_STACK(size), 8);
		inst = memory_copy(gen, inst, X86_64_RSP, 0, $1, 0, size);
		gen->stack_changed = 1;
	}

JIT_OP_POP_STACK:
	[] -> {
		x86_64_add_reg_imm_size(inst, X86_64_RSP, insn->value1->address, 8);
		gen->stack_changed = 1;
	}

JIT_OP_FLUSH_SMALL_STRUCT:
	[] -> {
		inst = flush_return_struct(inst, insn->value1);
	}

JIT_OP_RETURN:
	[] -> {
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_REG: manual
        [] -> {
		/* Nothing to do here */;
	}

JIT_OP_RETURN_INT: note
	[reg("rax")] -> {
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_LONG: note
	[reg("rax")] -> {
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_FLOAT32: note
	[xreg("xmm0")] -> {
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_FLOAT64: note
	[xreg("xmm0")] -> {
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_NFLOAT: note, stack
	[freg, clobber(freg)] -> {
		/* clobber(freg) frees all registers on the fp stack */
		inst = jump_to_epilog(gen, inst, block);
	}

JIT_OP_RETURN_SMALL_STRUCT: note
	[rreg, imm] -> {
		inst = return_struct(inst, func, $1);
		inst = jump_to_epilog(gen, inst, block);
	}

/*
 * Pointer-relative loads and stores.
 */

JIT_OP_LOAD_RELATIVE_SBYTE:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movsx8_reg_regp_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_movsx8_reg_membase_size(inst, $1, $2, $3, 8);
		}
	}

JIT_OP_LOAD_RELATIVE_UBYTE:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movzx8_reg_regp_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_movzx8_reg_membase_size(inst, $1, $2, $3, 8);
		}
	}

JIT_OP_LOAD_RELATIVE_SHORT:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movsx16_reg_regp_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_movsx16_reg_membase_size(inst, $1, $2, $3, 8);
		}
	}

JIT_OP_LOAD_RELATIVE_USHORT:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movzx16_reg_regp_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_movzx16_reg_membase_size(inst, $1, $2, $3, 8);
		}
	}

JIT_OP_LOAD_RELATIVE_INT:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_reg_regp_size(inst, $1, $2, 4);
		}
		else
		{
			x86_64_mov_reg_membase_size(inst, $1, $2, $3, 4);
		}
	}

JIT_OP_LOAD_RELATIVE_LONG:
	[=reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_reg_regp_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_mov_reg_membase_size(inst, $1, $2, $3, 8);
		}
	}

JIT_OP_LOAD_RELATIVE_FLOAT32:
	[=xreg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movss_reg_regp(inst, $1, $2);
		}
		else
		{
			x86_64_movss_reg_membase(inst, $1, $2, $3);
		}
	}

JIT_OP_LOAD_RELATIVE_FLOAT64:
	[=xreg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_movsd_reg_regp(inst, $1, $2);
		}
		else
		{		
			x86_64_movsd_reg_membase(inst, $1, $2, $3);
		}
	}
	
JIT_OP_LOAD_RELATIVE_NFLOAT:
	[=freg, reg, imm, if("sizeof(jit_nfloat) != sizeof(jit_float64)")] -> {
		x86_64_fld_membase_size(inst, $2, $3, 10);
	}
	[=freg, reg, imm, if("sizeof(jit_nfloat) == sizeof(jit_float64)")] -> {
		x86_64_fld_membase_size(inst, $2, $3, 8);
	}

JIT_OP_LOAD_RELATIVE_STRUCT: more_space
	[=frame, reg, imm, scratch reg, scratch xreg,
		if("jit_type_get_size(jit_value_get_type(insn->dest)) <= _JIT_MAX_MEMCPY_INLINE")] -> {
		inst = small_struct_copy(gen, inst, X86_64_RBP, $1, $2, $3,
								 jit_value_get_type(insn->dest), $4, $5);
	}
	[=frame, reg, imm, clobber(creg), clobber(xreg)] -> {
		inst = memory_copy(gen, inst, X86_64_RBP, $1, $2, $3,
				   jit_type_get_size(jit_value_get_type(insn->dest)));
	}

JIT_OP_STORE_RELATIVE_BYTE: ternary
	[reg, imm, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_imm_size(inst, $1, $2, 1);
		}
		else
		{
			x86_64_mov_membase_imm_size(inst, $1, $3, $2, 1);
		}
	}
	[reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_reg_size(inst, $1, $2, 1);
		}
		else
		{
			x86_64_mov_membase_reg_size(inst, $1, $3, $2, 1);
		}
	}

JIT_OP_STORE_RELATIVE_SHORT: ternary
	[reg, imm, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_imm_size(inst, $1, $2, 2);
		}
		else
		{
			x86_64_mov_membase_imm_size(inst, $1, $3, $2, 2);
		}
	}
	[reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_reg_size(inst, $1, $2, 2);
		}
		else
		{
			x86_64_mov_membase_reg_size(inst, $1, $3, $2, 2);
		}
	}

JIT_OP_STORE_RELATIVE_INT: ternary
	[reg, imm, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_imm_size(inst, $1, $2, 4);
		}
		else
		{
			x86_64_mov_membase_imm_size(inst, $1, $3, $2, 4);
		}
	}
	[reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_reg_size(inst, $1, $2, 4);
		}
		else
		{
			x86_64_mov_membase_reg_size(inst, $1, $3, $2, 4);
		}
	}

JIT_OP_STORE_RELATIVE_LONG: ternary
	[reg, imm, imm, if("$2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int")] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_imm_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_mov_membase_imm_size(inst, $1, $3, $2, 8);
		}
	}
	[reg, reg, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_reg_size(inst, $1, $2, 8);
		}
		else
		{
			x86_64_mov_membase_reg_size(inst, $1, $3, $2, 8);
		}
	}

JIT_OP_STORE_RELATIVE_FLOAT32: ternary
	[reg, imm, imm] -> {
		if($3 == 0)
		{
			x86_64_mov_regp_imm_size(inst, $1, ((jit_int *)($2))[0], 4);
		}
		else
		{
			x86_64_mov_membase_imm_size(inst, $1, $3, ((jit_int *)($2))[0], 4);
		}
	}
	[reg, xreg, imm] -> {
		if($3 == 0)
		{
			x86_64_movss_regp_reg(inst, $1, $2);
		}
		else
		{	
			x86_64_movss_membase_reg(inst, $1, $3, $2);
		}
	}

JIT_OP_STORE_RELATIVE_FLOAT64: ternary
	[reg, imm, imm] -> {
		x86_64_mov_membase_imm_size(inst, $1, $3, ((int *)($2))[0], 4);
		x86_64_mov_membase_imm_size(inst, $1, $3 + 4, ((int *)($2))[1], 4);
	}
	[reg, xreg, imm] -> {
		if($3 == 0)
		{
			x86_64_movsd_regp_reg(inst, $1, $2);
		}
		else
		{	
			x86_64_movsd_membase_reg(inst, $1, $3, $2);
		}
	}

JIT_OP_STORE_RELATIVE_STRUCT: ternary
	[reg, frame, imm, scratch reg, scratch xreg,
		if("jit_type_get_size(jit_value_get_type(insn->value1)) <= _JIT_MAX_MEMCPY_INLINE")] -> {
		inst = small_struct_copy(gen, inst, $1, $3, X86_64_RBP, $2,
								 jit_value_get_type(insn->value1), $4, $5);
	}
	[reg, frame, imm, clobber(creg), clobber(xreg)] -> {
		inst = memory_copy(gen, inst, $1, $3, X86_64_RBP, $2,
				   jit_type_get_size(jit_value_get_type(insn->value1)));
	}

JIT_OP_ADD_RELATIVE:
	[reg, imm, if("$2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int")] -> {
		if($2 != 0)
		{
			x86_64_add_reg_imm_size(inst, $1, $2, 8);
		}
	}

/*
 * Array element loads and stores.
 */

JIT_OP_LOAD_ELEMENT_SBYTE:
	[=reg, reg, reg] -> {
		x86_64_movsx8_reg_memindex_size(inst, $1, $2, 0, $3, 0, 4);
	}

JIT_OP_LOAD_ELEMENT_UBYTE:
	[=reg, reg, reg] -> {
		x86_64_movzx8_reg_memindex_size(inst, $1, $2, 0, $3, 0, 4);
	}

JIT_OP_LOAD_ELEMENT_SHORT:
	[=reg, reg, reg] -> {
		x86_64_movsx16_reg_memindex_size(inst, $1, $2, 0, $3, 1, 4);
	}

JIT_OP_LOAD_ELEMENT_USHORT:
	[=reg, reg, reg] -> {
		x86_64_movzx16_reg_memindex_size(inst, $1, $2, 0, $3, 1, 4);
	}

JIT_OP_LOAD_ELEMENT_INT:
	[=reg, reg, reg] -> {
		x86_64_mov_reg_memindex_size(inst, $1, $2, 0, $3, 2, 4);
	}

JIT_OP_LOAD_ELEMENT_LONG:
	[=reg, reg, reg] -> {
		x86_64_mov_reg_memindex_size(inst, $1, $2, 0, $3, 3, 8);
	}

JIT_OP_LOAD_ELEMENT_FLOAT32:
	[=xreg, reg, reg] -> {
		x86_64_movss_reg_memindex(inst, $1, $2, 0, $3, 2);
	}

JIT_OP_LOAD_ELEMENT_FLOAT64:
	[=xreg, reg, reg] -> {
		x86_64_movsd_reg_memindex(inst, $1, $2, 0, $3, 3);
	}

JIT_OP_STORE_ELEMENT_BYTE: ternary
	[reg, reg, reg] -> {
		x86_64_mov_memindex_reg_size(inst, $1, 0, $2, 0, $3, 1);
	}

JIT_OP_STORE_ELEMENT_SHORT: ternary
	[reg, reg, reg] -> {
		x86_64_mov_memindex_reg_size(inst, $1, 0, $2, 1, $3, 2);
	}

JIT_OP_STORE_ELEMENT_INT: ternary
	[reg, reg, reg] -> {
		x86_64_mov_memindex_reg_size(inst, $1, 0, $2, 2, $3, 4);
	}

JIT_OP_STORE_ELEMENT_LONG: ternary
	[reg, reg, imm] -> {
		if($3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int)
		{
			x86_64_mov_memindex_imm_size(inst, $1, 0, $2, 3, $3, 8);
		}
		else
		{
			jit_int *long_ptr = (jit_int *)(&($3));

			x86_64_mov_memindex_imm_size(inst, $1, 0, $2, 3, long_ptr[0], 4);
			x86_64_mov_memindex_imm_size(inst, $1, 4, $2, 3, long_ptr[1], 4);
		}
	}
	[reg, reg, reg] -> {
		x86_64_mov_memindex_reg_size(inst, $1, 0, $2, 3, $3, 8);
	}

JIT_OP_STORE_ELEMENT_FLOAT32: ternary
	[reg, reg, xreg] -> {
		x86_64_movss_memindex_reg(inst, $1, 0, $2, 2, $3);
	}

JIT_OP_STORE_ELEMENT_FLOAT64: ternary
	[reg, reg, xreg] -> {
		x86_64_movsd_memindex_reg(inst, $1, 0, $2, 3, $3);
	}

/*
 * Arithmetic opcodes.
 */

/*
 * 4 byte integer versions
 */

JIT_OP_IADD: commutative
	[reg, imm] -> {
		if($2 == 1)
		{
			x86_64_inc_reg_size(inst, $1, 4);
		}
		else
		{
			x86_64_add_reg_imm_size(inst, $1, $2, 4);
		}
	}
	[reg, local] -> {
		x86_64_add_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[reg, reg] -> {
		x86_64_add_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_ISUB:
	[reg, imm] -> {
		if($2 == 1)
		{
			x86_64_dec_reg_size(inst, $1, 4);
		}
		else
		{
			x86_64_sub_reg_imm_size(inst, $1, $2, 4);
		}
	}
	[reg, local] -> {
		x86_64_sub_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[reg, reg] -> {
		x86_64_sub_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_INEG:
	[reg] -> {
		x86_64_neg_reg_size(inst, $1, 4);
	}

/*
 * 8 byte integer versions
 */

JIT_OP_LADD: commutative
	[reg, imm, if("$2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int")] -> {
		if($2 == 1)
		{
			x86_64_inc_reg_size(inst, $1, 8);
		}
		else
		{
			x86_64_add_reg_imm_size(inst, $1, $2, 8);
		}
	}
	[reg, local] -> {
		x86_64_add_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}
	[reg, reg] -> {
		x86_64_add_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_LSUB:
	[reg, imm, if("$2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int")] -> {
		if($2 == 1)
		{
			x86_64_dec_reg_size(inst, $1, 8);
		}
		else
		{
			x86_64_sub_reg_imm_size(inst, $1, $2, 8);
		}
	}
	[reg, local] -> {
		x86_64_sub_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}
	[reg, reg] -> {
		x86_64_sub_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_LNEG:
	[reg] -> {
		x86_64_neg_reg_size(inst, $1, 8);
	}
/*
 * single precision float versions
 */

JIT_OP_FADD:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float32(gen, &inst, XMM1_ADD, $1, (jit_float32 *)$2);
	}
	[xreg, local] -> {
		x86_64_addss_reg_membase(inst, $1, X86_64_RBP, $2);
	}
	[xreg, xreg] -> {
		x86_64_addss_reg_reg(inst, $1, $2);
	}

JIT_OP_FSUB:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float32(gen, &inst, XMM1_SUB, $1, (jit_float32 *)$2);
	}
	[xreg, xreg] -> {
		x86_64_subss_reg_reg(inst, $1, $2);
	}
	[xreg, local] -> {
		x86_64_subss_reg_membase(inst, $1, X86_64_RBP, $2);
	}

JIT_OP_FMUL:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float32(gen, &inst, XMM1_MUL, $1, (jit_float32 *)$2);
	}
	[xreg, xreg] -> {
		x86_64_mulss_reg_reg(inst, $1, $2);
	}
	[xreg, local] -> {
		x86_64_mulss_reg_membase(inst, $1, X86_64_RBP, $2);
	}

JIT_OP_FDIV:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float32(gen, &inst, XMM1_DIV, $1, (jit_float32 *)$2);
	}
	[xreg, xreg] -> {
		x86_64_divss_reg_reg(inst, $1, $2);
	}
	[xreg, local] -> {
		x86_64_divss_reg_membase(inst, $1, X86_64_RBP, $2);
	}

/*
 * double precision float versions
 */

JIT_OP_DADD:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float64(gen, &inst, XMM1_ADD, $1, (jit_float64 *)$2);
	}
	[xreg, local] -> {
		x86_64_addsd_reg_membase(inst, $1, X86_64_RBP, $2);
	}
	[xreg, xreg] -> {
		x86_64_addsd_reg_reg(inst, $1, $2);
	}

JIT_OP_DSUB:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float64(gen, &inst, XMM1_SUB, $1, (jit_float64 *)$2);
	}
	[xreg, local] -> {
		x86_64_subsd_reg_membase(inst, $1, X86_64_RBP, $2);
	}
	[xreg, xreg] -> {
		x86_64_subsd_reg_reg(inst, $1, $2);
	}

JIT_OP_DMUL:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float64(gen, &inst, XMM1_MUL, $1, (jit_float64 *)$2);
	}
	[xreg, local] -> {
		x86_64_mulsd_reg_membase(inst, $1, X86_64_RBP, $2);
	}
	[xreg, xreg] -> {
		x86_64_mulsd_reg_reg(inst, $1, $2);
	}

JIT_OP_DDIV:
	[xreg, imm] -> {
		_jit_xmm1_reg_imm_size_float64(gen, &inst, XMM1_DIV, $1, (jit_float64 *)$2);
	}
	[xreg, local] -> {
		x86_64_divsd_reg_membase(inst, $1, X86_64_RBP, $2);
	}
	[xreg, xreg] -> {
		x86_64_divsd_reg_reg(inst, $1, $2);
	}

/*
 * Bitwise opcodes.
 */

JIT_OP_IAND: commutative
	[reg, imm] -> {
		x86_64_and_reg_imm_size(inst, $1, $2, 4);
	}
	[reg, local] -> {
		x86_64_and_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[reg, reg] -> {
		x86_64_and_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_IOR: commutative
	[reg, imm] -> {
		x86_64_or_reg_imm_size(inst, $1, $2, 4);
	}
	[reg, local] -> {
		x86_64_or_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[reg, reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_IXOR: commutative
	[reg, imm] -> {
		x86_64_xor_reg_imm_size(inst, $1, $2, 4);
	}
	[reg, local] -> {
		x86_64_xor_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
	}
	[reg, reg] -> {
		x86_64_xor_reg_reg_size(inst, $1, $2, 4);
	}

JIT_OP_INOT:
	[reg] -> {
		x86_64_not_reg_size(inst, $1, 4);
	}

JIT_OP_ISHL:
	[reg, imm] -> {
		x86_64_shl_reg_imm_size(inst, $1, ($2 & 0x1F), 4);
	}
	[sreg, reg("rcx")] -> {
		x86_64_shl_reg_size(inst, $1, 4);
	}

JIT_OP_ISHR:
	[reg, imm] -> {
		x86_64_sar_reg_imm_size(inst, $1, ($2 & 0x1F), 4);
	}
	[sreg, reg("rcx")] -> {
		x86_64_sar_reg_size(inst, $1, 4);
	}

JIT_OP_ISHR_UN:
	[reg, imm] -> {
		x86_64_shr_reg_imm_size(inst, $1, ($2 & 0x1F), 4);
	}
	[sreg, reg("rcx")] -> {
		x86_64_shr_reg_size(inst, $1, 4);
	}

JIT_OP_LAND: commutative
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_and_reg_imm_size(inst, $1, $2, 8);
	}
	[reg, local] -> {
		x86_64_and_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}
	[reg, reg] -> {
		x86_64_and_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_LOR: commutative
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_or_reg_imm_size(inst, $1, $2, 8);
	}
	[reg, local] -> {
		x86_64_or_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}
	[reg, reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_LXOR: commutative
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_xor_reg_imm_size(inst, $1, $2, 8);
	}
	[reg, local] -> {
		x86_64_xor_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
	}
	[reg, reg] -> {
		x86_64_xor_reg_reg_size(inst, $1, $2, 8);
	}

JIT_OP_LNOT:
	[reg] -> {
		x86_64_not_reg_size(inst, $1, 8);
	}

JIT_OP_LSHL:
	[reg, imm] -> {
		x86_64_shl_reg_imm_size(inst, $1, ($2 & 0x3F), 8);
	}
	[sreg, reg("rcx")] -> {
		x86_64_shl_reg_size(inst, $1, 8);
	}

JIT_OP_LSHR:
	[reg, imm] -> {
		x86_64_sar_reg_imm_size(inst, $1, ($2 & 0x3F), 8);
	}
	[sreg, reg("rcx")] -> {
		x86_64_sar_reg_size(inst, $1, 8);
	}

JIT_OP_LSHR_UN:
	[reg, imm] -> {
		x86_64_shr_reg_imm_size(inst, $1, ($2 & 0x3F), 8);
	}
	[sreg, reg("rcx")] -> {
		x86_64_shr_reg_size(inst, $1, 8);
	}

/*
 * Branch opcodes.
 */

JIT_OP_BR: branch
	[] -> {
		inst = output_branch(func, inst, 0xEB /* jmp */, insn);
	}

JIT_OP_BR_IFALSE: branch
	[reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 4);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}

JIT_OP_BR_ITRUE: branch
	[reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 4);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}

JIT_OP_BR_IEQ: branch
	[reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 4);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}

JIT_OP_BR_INE: branch
	[reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 4);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}

JIT_OP_BR_ILT: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}

JIT_OP_BR_ILT_UN: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}

JIT_OP_BR_ILE: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}

JIT_OP_BR_ILE_UN: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}

JIT_OP_BR_IGT: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}

JIT_OP_BR_IGT_UN: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}

JIT_OP_BR_IGE: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}

JIT_OP_BR_IGE_UN: branch
	[reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 4);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 4);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}

JIT_OP_BR_LFALSE: branch
	[reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 8);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}

JIT_OP_BR_LTRUE: branch
	[reg] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 8);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}

JIT_OP_BR_LEQ: branch
	[reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 8);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x74 /* eq */, insn);
	}

JIT_OP_BR_LNE: branch
	[reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $1, $1, 8);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x75 /* ne */, insn);
	}

JIT_OP_BR_LLT: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7C /* lt */, insn);
	}

JIT_OP_BR_LLT_UN: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x72 /* lt_un */, insn);
	}

JIT_OP_BR_LLE: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7E /* le */, insn);
	}

JIT_OP_BR_LLE_UN: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x76 /* le_un */, insn);
	}

JIT_OP_BR_LGT: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7F /* gt */, insn);
	}

JIT_OP_BR_LGT_UN: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x77 /* gt_un */, insn);
	}

JIT_OP_BR_LGE: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x7D /* ge */, insn);
	}

JIT_OP_BR_LGE_UN: branch
	[reg, imm, if("($2 >= (jit_nint)jit_min_int && $2 <= (jit_nint)jit_max_int)")] -> {
		x86_64_cmp_reg_imm_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}
	[reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $1, X86_64_RBP, $2, 8);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}
	[reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $1, $2, 8);
		inst = output_branch(func, inst, 0x73 /* ge_un */, insn);
	}

/*
 * Comparison opcodes.
 */

JIT_OP_IEQ:
	[=reg, reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $2, $2, 4);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}

JIT_OP_INE:
	[=reg, reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $2, $2, 4);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}

JIT_OP_ILT:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}

JIT_OP_ILT_UN:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}

JIT_OP_ILE:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}

JIT_OP_ILE_UN:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}

JIT_OP_IGT:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}

JIT_OP_IGT_UN:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}

JIT_OP_IGE:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}

JIT_OP_IGE_UN:
	[=reg, reg, imm] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 4);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}

JIT_OP_LEQ:
	[=reg, reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $2, $2, 8);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_EQ, 0);
	}

JIT_OP_LNE:
	[=reg, reg, immzero] -> {
		x86_64_or_reg_reg_size(inst, $2, $2, 8);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_NE, 0);
	}

JIT_OP_LLT:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 1);
	}

JIT_OP_LLT_UN:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LT, 0);
	}

JIT_OP_LLE:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 1);
	}

JIT_OP_LLE_UN:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_LE, 0);
	}

JIT_OP_LGT:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 1);
	}

JIT_OP_LGT_UN:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GT, 0);
	}

JIT_OP_LGE:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 1);
	}

JIT_OP_LGE_UN:
	[=reg, reg, imm, if("$3 >= (jit_nint)jit_min_int && $3 <= (jit_nint)jit_max_int")] -> {
		x86_64_cmp_reg_imm_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}
	[=reg, reg, local] -> {
		x86_64_cmp_reg_membase_size(inst, $2, X86_64_RBP, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}
	[=reg, reg, reg] -> {
		x86_64_cmp_reg_reg_size(inst, $2, $3, 8);
		inst = setcc_reg(inst, $1, X86_CC_GE, 0);
	}

/*
 * Pointer check opcodes.
 */

JIT_OP_CHECK_NULL: note
	[reg] -> {
#if 0 && defined(JIT_USE_SIGNALS)
		/* if $1 contains NULL this generates SEGV and the signal
		   handler will throw the exception  */
		x86_64_cmp_reg_membase_size(inst, $1, $1, 0, 8);
#else
		unsigned char *patch;
		x86_64_or_reg_reg_size(inst, $1, $1, 8);
		patch = inst;
		x86_branch8(inst, X86_CC_NE, 0, 0);
		inst = throw_builtin(inst, func, JIT_RESULT_NULL_REFERENCE);
		x86_patch(patch, inst);
#endif
	}

/*
 * Function calls.
 */

JIT_OP_CALL:
	[] -> {
		jit_function_t func = (jit_function_t)(insn->dest);
		inst = x86_64_call_code(inst, (jit_nint)jit_function_to_closure(func));
	}

JIT_OP_CALL_TAIL:
	[] -> {
		jit_function_t func = (jit_function_t)(insn->dest);
		x86_64_mov_reg_reg_size(inst, X86_64_RSP, X86_64_RBP, 8);
		x86_64_pop_reg_size(inst, X86_64_RBP, 8);
		x86_64_jump_to_code(inst, (jit_nint)jit_function_to_closure(func));
	}

JIT_OP_CALL_INDIRECT:
	[] -> {
		x86_64_call_reg(inst, X86_64_SCRATCH);
	}

JIT_OP_CALL_INDIRECT_TAIL:
	[] -> {
		x86_64_mov_reg_reg_size(inst, X86_64_RSP, X86_64_RBP, 8);
		x86_64_pop_reg_size(inst, X86_64_RBP, 8);
		x86_64_jmp_reg(inst, X86_64_SCRATCH);
	}

JIT_OP_CALL_VTABLE_PTR:
	[] -> {
		x86_64_call_reg(inst, X86_64_SCRATCH);
	}

JIT_OP_CALL_VTABLE_PTR_TAIL:
	[] -> {
		x86_64_mov_reg_reg_size(inst, X86_64_RSP, X86_64_RBP, 8);
		x86_64_pop_reg_size(inst, X86_64_RBP, 8);
		x86_64_jmp_reg(inst, X86_64_SCRATCH);
	}

JIT_OP_CALL_EXTERNAL:
	[] -> {
		inst = x86_64_call_code(inst, (jit_nint)(insn->dest));
	}

JIT_OP_CALL_EXTERNAL_TAIL:
	[] -> {
		x86_64_mov_reg_reg_size(inst, X86_64_RSP, X86_64_RBP, 8);
		x86_64_pop_reg_size(inst, X86_64_RBP, 8);
		x86_64_jump_to_code(inst, (jit_nint)(insn->dest));
	}


/*
 * Exception handling.
 */

JIT_OP_THROW: branch
	[reg] -> {
		x86_64_mov_reg_reg_size(inst, X86_64_RDI, $1, 8);
		if(func->builder->setjmp_value != 0)
		{
			jit_nint pc_offset;

			/* We have a "setjmp" block in the current function,
			   so we must record the location of the throw first */
			_jit_gen_fix_value(func->builder->setjmp_value);
			pc_offset = func->builder->setjmp_value->frame_offset +
							jit_jmp_catch_pc_offset;

			x86_64_lea_membase_size(inst, X86_64_SCRATCH, X86_64_RIP, 0, 8);
			x86_64_mov_membase_reg_size(inst, X86_64_RBP, pc_offset,
										X86_64_SCRATCH, 8);
		}
		inst = x86_64_call_code(inst, (jit_nint)jit_exception_throw);
	}

JIT_OP_RETHROW: manual
	[] -> { /* Not used in native code back ends */ }

JIT_OP_LOAD_PC:
	[=reg] -> {
		x86_64_lea_membase_size(inst, $1, X86_64_RIP, 0, 8);
	}

JIT_OP_LOAD_EXCEPTION_PC: manual
	[] -> { /* Not used in native code back ends */ }

JIT_OP_ENTER_FINALLY:
	[] -> {
		/* The return address is on the stack */
		x86_64_sub_reg_imm_size(inst, X86_64_RSP, 8, 8);
	 }

JIT_OP_LEAVE_FINALLY: branch
	[] -> {
		/* The "finally" return address is on the stack */
		x86_64_add_reg_imm_size(inst, X86_64_RSP, 8, 8);
		x86_64_ret(inst);
	}

JIT_OP_CALL_FINALLY: branch
	[] -> {
		jit_block_t block;

		block = jit_block_from_label(func, (jit_label_t)(insn->dest));
		if(!block)
		{
			return;
		}

		if(block->address)
		{
			inst = x86_64_call_code(inst, (jit_nint)block->address);
		}
		else
		{
			jit_int fixup;

			if(block->fixup_list)
			{
				fixup = _JIT_CALC_FIXUP(block->fixup_list, inst + 1);
			}
			else
			{
				fixup = 0;
			}
			block->fixup_list = (void *)(inst + 1);
			x86_64_call_imm(inst, fixup);
		}
	}

JIT_OP_ADDRESS_OF_LABEL:
	[=reg] -> {
		jit_int *fixup;

		block = jit_block_from_label(func, (jit_label_t)(insn->value1));
		if(block->address)
		{
			/* The label is in the current function so we assume that the */
			/* displacement to the current instruction is in the +-2GB range */

			x86_64_lea_membase_size(inst, $1, X86_64_RIP, 0, 8);
			fixup = (jit_int *)(inst - 4);
			fixup[0] = (jit_int)((jit_nint)block->address - (jit_nint)inst);
		}
		else
		{
			/* Output a placeholder and record on the block's fixup list */
			/* The label is in the current function so we assume that the */
			/* displacement to the current instruction will be in the +-2GB range */
			x86_64_lea_membase_size(inst, $1, X86_64_RIP, 0, 8);
			fixup = (jit_int *)(inst - 4);
			if(block->fixup_list)
			{
				fixup[0] = _JIT_CALC_FIXUP(block->fixup_list, fixup);
			}
			block->fixup_list = (void *)fixup;
		}
	}

/*
 * Block operations.
 */

JIT_OP_MEMCPY: ternary
	[any, any, imm, if("$3 <= 0")] -> { }
	[reg, reg, imm, scratch reg, scratch xreg,
		if("$3 <= _JIT_MAX_MEMCPY_INLINE")] -> {
		inst = small_block_copy(gen, inst, $1, 0, $2, 0, $3, $4, $5, 0);
	}
	[reg, reg, imm, clobber(creg), clobber(xreg)] -> {
		inst = memory_copy(gen, inst, $1, 0, $2, 0, $3);
	}
	[reg("rdi"), reg("rsi"), reg("rdx"), clobber(creg), clobber(xreg)] -> {
		inst = x86_64_call_code(inst, (jit_nint)jit_memcpy);
	}

JIT_OP_MEMSET: ternary
	[reg("rdi"), reg("rsi"), reg("rdx"), clobber(creg), clobber(xreg)] -> {
		inst = x86_64_call_code(inst, (jit_nint)jit_memset);
	}

JIT_OP_JUMP_TABLE: ternary, branch
	[reg, imm, imm, scratch reg, space("64")] -> {
		unsigned char *patch_jump_table;
		unsigned char *patch_fall_through;
		int index;
		jit_label_t *labels;
		jit_nint num_labels;
		jit_block_t block;

		labels = (jit_label_t *) $2;
		num_labels = $3;

		patch_jump_table = (unsigned char *)_jit_cache_alloc(&(gen->posn),
														 sizeof(void *) * $3);
		if(!patch_jump_table)
		{
			/* The cache is full */
			return;
		}

		x86_64_mov_reg_imm_size(inst, $4, (jit_nint)patch_jump_table, 8);
		x86_64_cmp_reg_imm_size(inst, $1, num_labels, 8);
		patch_fall_through = inst;
		x86_branch32(inst, X86_CC_AE, 0, 0);

		if(func->builder->position_independent)
		{
			/* TODO */
			TODO();
		}
		else
		{
			x86_64_jmp_memindex(inst, $4, 0, $1, 3);
		}

		for(index = 0; index < num_labels; index++)
		{
			block = jit_block_from_label(func, labels[index]);
			if(!block)
			{
				return;
			}

			if(func->builder->position_independent)
			{
				/* TODO */
				TODO();
			}
			else
			{
				if(block->address)
				{
					x86_64_imm_emit64(patch_jump_table, (jit_nint)(block->address));
				}
				else
				{
					/* Output a placeholder and record on the block's absolute fixup list */
					x86_64_imm_emit64(patch_jump_table, (jit_nint)(block->fixup_absolute_list));
					block->fixup_absolute_list = (void *)(patch_jump_table - 8);
				}
			}
		}

		x86_patch(patch_fall_through, inst);
	}
